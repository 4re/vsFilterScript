#pragma once
#include "VideoFrame.vxx"
#include "Node.vxx"

struct VideoNode : Node, VideoInfo, VideoFormat {
private:
	using PaddingFunctionInterface = auto(const VideoNode&, std::ptrdiff_t, FrameContextWrapper)->FrameReference;
	using PaddingFunctionType = std::function<PaddingFunctionInterface>;

public:
	field(PaddingFunction, PaddingFunctionType{});

public:
	VideoNode() = default;
	VideoNode(std::convertible_to<HandleType> auto&& Descriptor) : Node{ Forward(Descriptor) } {
		auto SynchronizeFormat = [this] {
			auto& FlattenedFormat = static_cast<VideoFormat&>(*this);
			if (auto& ReferenceFormat = *this->Format; this->Format != nullptr)
				FlattenedFormat = ReferenceFormat;
		};
		auto SynchronizeVideoInfo = [this] {
			auto& ReferenceVideoInfo = this->QueryVideoInfo();
			auto& FlattenedVideoInfo = static_cast<VideoInfo&>(*this);
			FlattenedVideoInfo = ReferenceVideoInfo;
		};
		SynchronizeVideoInfo();
		SynchronizeFormat();
		this->PaddingFunction = PaddingFunctions::Node::Default;
	}

public:
	auto RequestFrame(std::integral auto Index, auto FrameContext) const {
		if (Index >= 0 && Index < FrameCount)
			RequestFrameUnchecked(Index, FrameContext);
	}
	auto RequestFrames(std::integral auto Index, auto FrameContext, auto&& RequestFunction) const {
		for (auto x : RequestFunction(Index))
			RequestFrame(x, FrameContext);
		if (WasRequestFunctionAlreadyCached() == false)
			Utility::PointerDropQualifiers(this)->CacheRequestFunction(Forward(RequestFunction));
	}

private:
	auto AccessFrame(auto Index, auto FrameContext) const {
		if (Index < 0 || Index >= FrameCount)
			return PaddingFunction(*this, Index, FrameContext);
		else
			return AccessFrameUnchecked(Index, FrameContext);
	}

public:
	template<typename PixelType, auto DirectAccess = false>
	auto FetchFrame(std::integral auto Index, auto FrameContext) const {
		return VideoFrame<PixelType, DirectAccess>{ AccessFrame(Index, FrameContext) };
	}
	template<typename PixelType, auto DirectAccess = false>
	auto FetchFrames(std::integral auto Index, auto FrameContext) const {
		using FrameType = VideoFrame<PixelType, DirectAccess>;
		auto FetchedFrames = std::unordered_map<std::ptrdiff_t, FrameType>{};
		auto RequestedFrameIndexes = RequestFunction(Index);
		FetchedFrames.rehash(RequestedFrameIndexes.size());
		for (auto x : RequestedFrameIndexes)
			FetchedFrames[x - Index] = FetchFrame<PixelType, DirectAccess>(x, FrameContext);
		return FetchedFrames;
	}

public:
	auto& ExtractMetadata() const {
		return static_cast<const VideoInfo&>(*this);
	}
	auto PeekFrame(std::integral auto Index, auto FrameContext) const {
		return Frame{ AccessFrame(Index, FrameContext) };
	}
	using Node::PeekFrame;
};

namespace PaddingFunctions::VideoNode {
	auto Constant(auto Core, auto&& Values) {
		return [Core, Values = Utility::TypeEraseIterableToTriplet(Forward(Values))](auto& Clip, auto Index, auto...) {
			if (!Clip.WithConstantFormat() || !Clip.WithConstantDimensions())
				throw RuntimeError{ "PaddingFunctions::VideoNode::Constant: only clips with constant format and dimensions supported." };
			auto AllocatedFrame = Core.AllocateVideoFrame(Clip.Format, Clip.Width, Clip.Height);
			auto FillWithColor = [&](auto&& BlankFrame) {
				using PixelType = std::decay_t<decltype(BlankFrame[0][0][0])>;
				for (auto c : Range{ BlankFrame.PlaneCount })
					for (auto y : Range{ BlankFrame[c].Height })
						for (auto x : Range{ BlankFrame[c].Width })
							BlankFrame[c][y][x] = static_cast<PixelType>(Values[c]);
				return BlankFrame.Transfer();
			};
			if (Clip.IsSinglePrecision())
				return FillWithColor(VideoFrame<float>{ AllocatedFrame.Leak() });
			else if (Clip.BitsPerSample > 8)
				return FillWithColor(VideoFrame<std::uint16_t>{ AllocatedFrame.Leak() });
			else
				return FillWithColor(VideoFrame<std::uint8_t>{ AllocatedFrame.Leak() });
		};
	}
	auto Zero(auto Core) {
		return [=](auto& Clip, auto Index, auto...) {
			if (Clip.IsRGB() || Clip.IsGray() || Clip.IsSinglePrecision())
				return Constant(Core, 0)(Clip, Index);
			else
				return Constant(Core, std::array{ 0, 1 << (Clip.BitsPerSample - 1) })(Clip, Index);
		};
	}
}