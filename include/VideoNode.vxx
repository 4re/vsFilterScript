#pragma once
#include "VideoFrame.vxx"
#include "Node.vxx"

struct VideoNode : Node, VideoInfo, VideoFormat {
private:
	using PaddingFunctionInterface = auto(const VideoNode&, std::ptrdiff_t, FrameContextWrapper)->FrameReference;
	using PaddingFunctionType = std::function<PaddingFunctionInterface>;

public:
	field(PaddingFunction, PaddingFunctionType{});

public:
	VideoNode() = default;
	VideoNode(std::convertible_to<HandleType> auto&& Descriptor) : Node{ Forward(Descriptor) } {
		auto SynchronizeFormat = [this] {
			auto& FlattenedFormat = static_cast<VideoFormat&>(*this);
			if (auto& ReferenceFormat = *this->Format; this->Format != nullptr)
				FlattenedFormat = ReferenceFormat;
		};
		auto SynchronizeVideoInfo = [this] {
			auto& ReferenceVideoInfo = this->QueryVideoInfo();
			auto& FlattenedVideoInfo = static_cast<VideoInfo&>(*this);
			FlattenedVideoInfo = ReferenceVideoInfo;
		};
		SynchronizeVideoInfo();
		SynchronizeFormat();
		this->PaddingFunction = PaddingFunctions::Node::Default;
	}

public:
	auto RequestFrame(std::integral auto Index, auto FrameContext) const {
		if (Index >= 0 && Index < FrameCount)
			RequestFrameUnchecked(Index, FrameContext);
	}
	auto RequestFrames(std::integral auto Index, auto FrameContext, auto&& RequestFunction) const {
		for (auto RequestedFrameIndexes = RequestFunction(Index); auto x : RequestedFrameIndexes)
			RequestFrame(x, FrameContext);
		if (WasRequestFunctionAlreadyCached() == false)
			CacheRequestFunction(Forward(RequestFunction));
	}

private:
	auto AccessFrame(auto Index, auto FrameContext) const {
		if (Index < 0 || Index >= FrameCount)
			return PaddingFunction(*this, Index, FrameContext);
		else
			return AccessFrameUnchecked(Index, FrameContext);
	}

public:
	template<typename PixelType, auto DirectAccess = false>
	auto FetchFrame(std::integral auto Index, auto FrameContext) const {
		return VideoFrame<PixelType, DirectAccess>{ AccessFrame(Index, FrameContext).Leak() };
	}
	template<typename PixelType, auto DirectAccess = false>
	auto FetchFrames(std::integral auto Index, auto FrameContext) const {
		using FrameType = VideoFrame<PixelType, DirectAccess>;
		auto FetchedFrames = std::unordered_map<std::ptrdiff_t, FrameType>{};
		auto RequestedFrameIndexes = RequestFunction(Index);
		FetchedFrames.rehash(RequestedFrameIndexes.size());
		for (auto x : RequestedFrameIndexes)
			FetchedFrames[x - Index] = FetchFrame<PixelType, DirectAccess>(x, FrameContext);
		return FetchedFrames;
	}

public:
	auto& ExtractMetadata() const {
		return static_cast<const VideoInfo&>(*this);
	}
	auto PeekFrame(std::integral auto Index, auto FrameContext) const {
		return Frame{ AccessFrame(Index, FrameContext).Leak() };
	}
	using Node::PeekFrame;
};

namespace PaddingFunctions::VideoNode {
	auto Constant(auto Core, auto&& Values) {
		return [Core, Values = Forward(Values)](auto& Clip, auto Index, auto...) {
			if (!Clip.WithConstantFormat() || !Clip.WithConstantDimensions())
				throw RuntimeError{ "PaddingFunctions::VideoNode::Constant: only clips with constant format and dimensions supported." };
			auto FrameHandle = Core.AllocateFrame(Clip.Format, Clip.Width, Clip.Height);
			if (Clip.IsSinglePrecision())
				return Utility::PaddingFunctions::ColorBlankFrame(VideoFrame<float>{ FrameHandle }, Values);
			else if (Clip.BitsPerSample > 8)
				return Utility::PaddingFunctions::ColorBlankFrame(VideoFrame<std::uint16_t>{ FrameHandle }, Values);
			else
				return Utility::PaddingFunctions::ColorBlankFrame(VideoFrame<std::uint8_t>{ FrameHandle }, Values);
		};
	}
	auto Zero(auto Core) {
		return [=](auto& Clip, auto Index, auto...) {
			if (Clip.IsRGB() || Clip.IsGray() || Clip.IsSinglePrecision())
				return Constant(Core, 0)(Clip, Index);
			else
				return Constant(Core, std::array{ 0, 1 << (Clip.BitsPerSample - 1) })(Clip, Index);
		};
	}
}