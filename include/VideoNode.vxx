#pragma once
#include "VideoFrame.vxx"
#include "Node.vxx"

struct VideoNode : Node, VideoInfo, VideoFormat {
private:
	using PaddingFunctionInterface = auto(const VideoNode&, std::ptrdiff_t, FrameContextWrapper)->FrameReference;
	using PaddingFunctionType = std::function<PaddingFunctionInterface>;

public:
	field(PaddingFunction, PaddingFunctionType{});

public:
	VideoNode() = default;
	VideoNode(std::convertible_to<HandleType> auto&& Descriptor) : Node{ Forward(Descriptor) } {
		auto SynchronizeFormat = [this] {
			auto& FlattenedFormat = static_cast<VideoFormat&>(*this);
			if (auto& ReferenceFormat = *this->Format; this->Format != nullptr)
				FlattenedFormat = ReferenceFormat;
		};
		auto SynchronizeVideoInfo = [this] {
			auto& ReferenceVideoInfo = this->QueryVideoInfo();
			auto& FlattenedVideoInfo = static_cast<VideoInfo&>(*this);
			FlattenedVideoInfo = ReferenceVideoInfo;
		};
		SynchronizeVideoInfo();
		SynchronizeFormat();
		this->PaddingFunction = PaddingFunctions::Node::Default;
	}

public:
	auto RequestFrame(std::integral auto Index, auto FrameContext) const {
		if (Index >= 0 && Index < FrameCount)
			RequestFrameUnchecked(Index, FrameContext);
	}
	auto RequestFrames(std::integral auto Index, auto FrameContext, auto&& GeneralizedRequestFunction) const {
		for (auto RequestedFrameIndexes = GeneralizedRequestFunction(Index); auto x : RequestedFrameIndexes)
			RequestFrame(x, FrameContext);
		if (!RequestFunction)
			SetRequestFunction(Forward(GeneralizedRequestFunction));
	}

private:
	auto AccessFrame(auto Index, auto FrameContext) const {
		if (Index < 0 || Index >= FrameCount)
			return PaddingFunction(*this, Index, FrameContext);
		else
			return AccessFrameUnchecked(Index, FrameContext);
	}

public:
	template<typename PixelType, auto DirectAccess = false>
	auto FetchFrame(std::integral auto Index, auto FrameContext) const {
		return VideoFrame<PixelType, DirectAccess>{ AccessFrame(Index, FrameContext).Leak() };
	}
	template<typename PixelType, auto DirectAccess = false>
	auto FetchFrames(std::integral auto Index, auto FrameContext) const {
		using FrameType = VideoFrame<PixelType, DirectAccess>;
		auto FetchedFrames = std::unordered_map<std::ptrdiff_t, FrameType>{};
		auto RequestedFrameIndexes = RequestFunction(Index);
		FetchedFrames.rehash(RequestedFrameIndexes.size());
		for (auto x : RequestedFrameIndexes)
			FetchedFrames[x - Index] = FetchFrame<PixelType, DirectAccess>(x, FrameContext);
		return FetchedFrames;
	}

public:
	auto& ExtractMetadata() const {
		return static_cast<const VideoInfo&>(*this);
	}
	auto PeekFrame(std::integral auto Index, auto FrameContext) const {
		return Frame{ AccessFrame(Index, FrameContext).Leak() };
	}
	using Node::PeekFrame;
};

namespace PaddingFunctions::Utility::Video {
	auto ColorBlankFrame(auto&& BlankFrame, auto&& Color) {
		using PixelType = std::decay_t<decltype(BlankFrame[0][0][0])>;
		auto GeneratePalette = [&] {
			if constexpr (requires { Color.begin(); }) {
				auto PaletteBuffer = std::vector<PixelType>{};
				for (auto&& x : Color)
					PaletteBuffer.push_back(static_cast<PixelType>(x));
				if (PaletteBuffer.size() >= 3)
					return std::array{ PaletteBuffer[0], PaletteBuffer[1], PaletteBuffer[2] };
				else if (PaletteBuffer.size() == 2)
					return std::array{ PaletteBuffer[0], PaletteBuffer[1], PaletteBuffer[1] };
				else if (PaletteBuffer.size() == 1)
					return std::array{ PaletteBuffer[0], PaletteBuffer[0], PaletteBuffer[0] };
				else
					throw RuntimeError{ "PaddingFunctions::Utility::Video::ColorBlankFrame: failed to generate color palette." };
			}
			else {
				auto Intensity = static_cast<PixelType>(Color);
				return std::array{ Intensity, Intensity, Intensity };
			}
		};
		auto Palette = GeneratePalette();
		for (auto c : Range{ BlankFrame.PlaneCount })
			for (auto y : Range{ BlankFrame[c].Height })
				for (auto x : Range{ BlankFrame[c].Width })
					BlankFrame[c][y][x] = Palette[c];
		return BlankFrame.Transfer();
	}
}

namespace PaddingFunctions::VideoNode {
	auto Constant(auto Core, auto&& Values) {
		return [Core, Values = Forward(Values)](auto& Clip, auto Index, auto...) {
			if (!Clip.WithConstantFormat() || !Clip.WithConstantDimensions())
				throw RuntimeError{ "PaddingFunctions::VideoNode::Constant: only clips with constant format and dimensions supported." };
			auto FrameHandle = Core.AllocateFrame(Clip.Format, Clip.Width, Clip.Height);
			if (Clip.IsSinglePrecision())
				return Utility::Video::ColorBlankFrame(VideoFrame<float>{ FrameHandle }, Values);
			else if (Clip.BitsPerSample > 8)
				return Utility::Video::ColorBlankFrame(VideoFrame<std::uint16_t>{ FrameHandle }, Values);
			else
				return Utility::Video::ColorBlankFrame(VideoFrame<std::uint8_t>{ FrameHandle }, Values);
		};
	}
	auto Zero(auto Core) {
		return [=](auto& Clip, auto Index, auto...) {
			if (Clip.IsRGB() || Clip.IsGray() || Clip.IsSinglePrecision())
				return Constant(Core, 0)(Clip, Index);
			else
				return Constant(Core, std::array{ 0, 1 << (Clip.BitsPerSample - 1) })(Clip, Index);
		};
	}
}