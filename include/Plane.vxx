#pragma once
#include "Utility.vxx"

template<typename PixelType, auto DirectAccess>
struct Plane {
	field(Width, 0_size);
	field(Height, 0_size);
	field(Canvas, std::vector<PixelType*>{});

public:
	static constexpr auto Readonly = std::is_const_v<PixelType>;
	static constexpr auto EnabledAutomaticPadding = Readonly && !DirectAccess;

private:
	using EmptyType = struct {};
	using PaddingFunctionInterface = auto(PixelType**, std::size_t, std::size_t, std::ptrdiff_t, std::ptrdiff_t)->PixelType;
	using PaddingFunctionType = std::function<PaddingFunctionInterface>;
	using ReifiedPaddingFunctionType = std::conditional_t<EnabledAutomaticPadding, PaddingFunctionType, EmptyType>;

public:
	[[no_unique_address]]
	field(PaddingFunction, ReifiedPaddingFunctionType{});

private:
	struct PaddedAccess {
		field(TargetPlane, static_cast<const Plane*>(nullptr));
		field(yAbsolute, 0_ptrdiff);
		field(xOffset, 0_ptrdiff);

	public:
		auto operator[](std::integral auto x) const {
			auto xAbsolute = x + xOffset;
			auto PlaneWidth = TargetPlane->Width;
			auto PlaneHeight = TargetPlane->Height;
			auto Canvas = Utility::PointerDropQualifiers(TargetPlane)->Canvas.data();
			if (xAbsolute < 0 || yAbsolute < 0 || xAbsolute >= PlaneWidth || yAbsolute >= PlaneHeight)
				return TargetPlane->PaddingFunction(Canvas, PlaneWidth, PlaneHeight, yAbsolute, xAbsolute);
			else [[likely]]
				return TargetPlane->Canvas[yAbsolute][xAbsolute];
		}
	};

private:
	struct PlaneView {
		field(TargetPlane, static_cast<const Plane*>(nullptr));
		field(yOffset, 0_ptrdiff);
		field(xOffset, 0_ptrdiff);

	public:
		auto operator[](std::integral auto y) const {
			return PaddedAccess{ .TargetPlane = TargetPlane, .yAbsolute = y + yOffset, .xOffset = xOffset };
		}
		auto GetCoordinates() const {
			return std::array{ yOffset, xOffset };
		}
		auto View(std::integral auto y, std::integral auto x) const {
			return PlaneView{ .TargetPlane = TargetPlane, .yOffset = yOffset + y, .xOffset = xOffset + x };
		}
	};

public:
	Plane() = default;
	Plane(auto Pointer, auto Width, auto Height, auto Stride, auto&& PaddingFunction) {
		this->Canvas.resize(Height);
		this->Width = Width;
		this->Height = Height;
		if constexpr (EnabledAutomaticPadding)
			this->PaddingFunction = Forward(PaddingFunction);
		for (auto Origin = reinterpret_cast<PixelType*>(Pointer); auto y : Range{ Height })
			this->Canvas[y] = Origin + y * Stride;
	}

public:
	auto operator[](std::integral auto y) const {
		if constexpr (EnabledAutomaticPadding)
			return PaddedAccess{ .TargetPlane = this, .yAbsolute = y };
		else
			return Canvas[y];
	}
	auto View(std::integral auto y, std::integral auto x) const {
		static_assert(EnabledAutomaticPadding, "View() is only available when automatic padding is enabled!");
		return PlaneView{ .TargetPlane = this, .yOffset = y, .xOffset = x };
	}
};

namespace PaddingFunctions::Plane {
	auto Constant(auto Value) {
		return [=](auto Canvas, auto Width, auto Height, auto y, auto x) {
			using PixelType = std::decay_t<decltype(Canvas[0][0])>;
			return static_cast<PixelType>(Value);
		};
	}
	auto Repeat = [](auto Canvas, auto Width, auto Height, auto y, auto x) {
		x = Utility::Min(Utility::Max(x, 0), Width - 1);
		y = Utility::Min(Utility::Max(y, 0), Height - 1);
		return Canvas[y][x];
	};
	auto Reflect = [](auto Canvas, auto Width, auto Height, auto y, auto x) {
		x = Utility::PaddingFunctions::ReflectCoordinate(x, Width);
		y = Utility::PaddingFunctions::ReflectCoordinate(y, Height);
		return Canvas[y][x];
	};
	auto Zero = Constant(0);
	auto Default = Reflect;
}