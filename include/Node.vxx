#pragma once
#include "ResourceManager.vxx"
#include "Metadata.vxx"

using NodeReference = Owner<VSNodeRef>;

struct Node : NodeReference {
private:
	using RequestFunctionInterface = auto(std::ptrdiff_t)->std::vector<std::ptrdiff_t>;
	using RequestFunctionType = std::function<RequestFunctionInterface>;

protected:
	field(RequestFunction, RequestFunctionType{});

public:
	Node() = default;
	Node(std::convertible_to<HandleType> auto&& Descriptor) : NodeReference{ Forward(Descriptor) } {}

public:
	auto RequestFrameUnchecked(std::integral auto Index, auto FrameContext) const {
		VaporGlobals::API->requestFrameFilter(Index, Handle, FrameContext);
	}
	auto AccessFrameUnchecked(std::integral auto Index, auto FrameContext) const {
		return FrameReference{ VaporGlobals::API->getFrameFilter(Index, Handle, FrameContext) };
	}
	auto PeekFrame(std::integral auto Index) const {
		auto ErrorMessageBuffer = std::array<char, 1024>{};
		auto FrameHandle = VaporGlobals::API->getFrame(Index, Handle, ErrorMessageBuffer.data(), 1024);
		if (FrameHandle == Frame::NullHandle)
			throw RuntimeError{ ErrorMessageBuffer.data() };
		return Frame{ FrameHandle };
	}
	auto WasRequestFunctionAlreadyCached() const {
		return static_cast<bool>(RequestFunction);
	}
	auto CacheRequestFunction(auto&& RequestFunction) {
		if constexpr (SubtypeOf<decltype(RequestFunction(0_ptrdiff)), std::vector<std::ptrdiff_t>>)
			this->RequestFunction = Forward(RequestFunction);
		else
			this->RequestFunction = [RequestFunction = Forward(RequestFunction)](auto Index) {
				auto TypeErasedContainer = std::vector<std::ptrdiff_t>{};
				for (auto x : RequestFunction(Index))
					TypeErasedContainer.push_back(x);
				return TypeErasedContainer;
			};
	}
	auto Type() const {
		//Placeholder for API v4.
	}
	auto& QueryVideoInfo() const {
		auto InfoHandle = VaporGlobals::API->getVideoInfo(Handle);
		return reinterpret_cast<const VideoInfo&>(*InfoHandle);
	}
	auto QueryAudioInfo() const {
		//Placeholder for API v4.
	}

public:
	template<std::derived_from<NodeReference> NodeType>
	operator NodeType() && {
		auto TargetNode = NodeType{ this->Leak() };
		TargetNode.RequestFunction = std::move(this->RequestFunction);
		return TargetNode;
	}
	template<std::derived_from<NodeReference> NodeType>
	operator NodeType() const & {
		auto TargetNode = NodeType{ this->CloneHandle() };
		TargetNode.RequestFunction = this->RequestFunction;
		return TargetNode;
	}
};

namespace PaddingFunctions::Node {
	auto Repeat = [](auto& Clip, auto Index, auto FrameContext) {
		Index = Utility::Min(Utility::Max(Index, 0), Clip.FrameCount - 1);
		return Clip.AccessFrameUnchecked(Index, FrameContext);
	};
	auto Reflect = [](auto& Clip, auto Index, auto FrameContext) {
		Index = Utility::PaddingFunctions::ReflectCoordinate(Index, Clip.FrameCount);
		return Clip.AccessFrameUnchecked(Index, FrameContext);
	};
	auto Default = Reflect;
}