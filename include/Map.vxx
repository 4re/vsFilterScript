#pragma once
#include "VideoNode.vxx"
#include "AudioNode.vxx"
#include "Function.vxx"

template<auto Readonly, auto Managed>
struct Item {
	field(Index, 0_ptrdiff);

private:
	struct SharedAccess : MapReference<Managed> {
		field(Key, ""s);

	public:
		SharedAccess() = default;
		SharedAccess(auto&& Descriptor, auto&& Key) : MapReference<Managed>{ Forward(Descriptor) } {
			this->Key = static_cast<std::string>(Forward(Key));
		}
	};

private:
	struct Iterator {
		field(TargetItem, static_cast<const Item*>(nullptr));
		field(Index, 0_ptrdiff);

	public:
		auto operator*() const {
			auto& ItemReference = *TargetItem;
			return ItemReference[Index];
		}
		auto& operator++() {
			++Index;
			return *this;
		}
		auto operator!=(auto&& OtherIterator) const {
			return Index != OtherIterator.Index;
		}
	};

public:
	field(Access, std::shared_ptr<SharedAccess>{});

public:
	Item() = default;
	Item(auto&& Descriptor, std::convertible_to<std::string> auto&& Key) {
		this->Access = std::make_shared<SharedAccess>(Forward(Descriptor), Forward(Key));
	}

public:
	auto Exists() const {
		return Index < size();
	}
	auto Type() const {
		return static_cast<ItemTypes>(VaporGlobals::API->propGetType(Access->Handle, Access->Key.data()));
	}
	auto operator[](std::integral auto Index) const {
		auto Replica = *this;
		Replica.Index = Index;
		return Replica;
	}

public:
	auto size() const {
		return Utility::Max(VaporGlobals::API->propNumElements(Access->Handle, Access->Key.data()), 0);
	}
	auto begin() const {
		return Iterator{ .TargetItem = this, .Index = 0 };
	}
	auto end() const {
		return Iterator{ .TargetItem = this, .Index = size() };
	}

public:
	template<std::floating_point TargetType>
	operator TargetType() const {
		return VaporGlobals::API->propGetFloat(Access->Handle, Access->Key.data(), Index, nullptr);
	}

public:
	template<std::integral TargetType>
	operator TargetType() const {
		return VaporGlobals::API->propGetInt(Access->Handle, Access->Key.data(), Index, nullptr);
	}

public:
	operator std::string() const {
		return { VaporGlobals::API->propGetData(Access->Handle, Access->Key.data(), Index, nullptr) };
	}

public:
	template<std::derived_from<NodeReference> TargetType>
	operator TargetType() const {
		return { VaporGlobals::API->propGetNode(Access->Handle, Access->Key.data(), Index, nullptr) };
	}

public:
	template<std::derived_from<FrameReference> TargetType>
	operator TargetType() const {
		return { VaporGlobals::API->propGetFrame(Access->Handle, Access->Key.data(), Index, nullptr) };
	}

public:
	template<std::derived_from<FunctionReference> TargetType>
	operator TargetType() const {
		return { VaporGlobals::API->propGetFunc(Access->Handle, Access->Key.data(), Index, nullptr) };
	}

private:
	auto InsertValue(auto&& Value, auto AppendMode) const {
		static_assert(Readonly == false, "Item: cannot modify readonly item");
		using ValueType = std::decay_t<decltype(Value)>;
		if constexpr (std::floating_point<ValueType>)
			VaporGlobals::API->propSetFloat(Access->Handle, Access->Key.data(), Value, AppendMode);
		else if constexpr (std::integral<ValueType>)
			VaporGlobals::API->propSetInt(Access->Handle, Access->Key.data(), Value, AppendMode);
		else if constexpr (std::convertible_to<ValueType, const char*>)
			VaporGlobals::API->propSetData(Access->Handle, Access->Key.data(), Value, -1, AppendMode);
		else if constexpr (requires { Value.size(); { Value.data() }->std::convertible_to<const char*>; })
			VaporGlobals::API->propSetData(Access->Handle, Access->Key.data(), Value.data(), Value.size(), AppendMode);
		else if constexpr (SubtypeOf<ValueType, NodeReference>)
			VaporGlobals::API->propSetNode(Access->Handle, Access->Key.data(), Value.Handle, AppendMode);
		else if constexpr (SubtypeOf<ValueType, FrameReference>)
			VaporGlobals::API->propSetFrame(Access->Handle, Access->Key.data(), Value.Handle, AppendMode);
		else if constexpr (SubtypeOf<ValueType, FunctionReference>)
			VaporGlobals::API->propSetFunc(Access->Handle, Access->Key.data(), Value.Handle, AppendMode);
	}

public:
	auto Erase() const {
		static_assert(Readonly == false, "Item: cannot erase readonly item");
		return VaporGlobals::API->propDeleteKey(Access->Handle, Access->Key.data()) == 1;
	}
	auto& operator=(AnyBut<Item> auto&& Entity) const {
		InsertValue(Forward(Entity), VSPropAppendMode::paReplace);
		return *this;
	}
	auto& operator+=(auto&& Entity) const {
		InsertValue(Forward(Entity), VSPropAppendMode::paAppend);
		return *this;
	}
	auto& operator|=(auto&& Entity) const {
		InsertValue(Forward(Entity), VSPropAppendMode::paTouch);
		return *this;
	}
};

template<auto Readonly = true, auto Managed = true>
auto AccessMap(auto MapHandle, auto&& Key) {
	return Item<Readonly, Managed>{  MapHandle, Forward(Key) };
}

struct ArgumentList final {
	self(InputMap, static_cast<const VSMap*>(nullptr));
	auto operator[](auto&& Parameter) {
		return AccessMap(InputMap, Forward(Parameter));
	}
};

template<typename FilterType>
struct Controller final {
	self(OutputMap, static_cast<VSMap*>(nullptr));
	auto RaiseError(auto&& ErrorMessage) {
		auto Caption = FilterType::Name + ": "s;
		auto DecoratedMessage = Caption + ErrorMessage;
		VaporGlobals::API->setError(OutputMap, ExposeCString(DecoratedMessage));
	}
	auto Receive(auto&& VideoOutput) {
		auto OutputSequence = AccessMap<false>(OutputMap, "clip");
		if constexpr (requires { VideoOutput.size(); })
			for (auto&& x : VideoOutput)
				OutputSequence += x;
		else
			OutputSequence = VideoOutput;
	}
	auto Receive(auto&& ...VideoOutputs) {
		Receive(std::array{ Forward(VideoOutputs)... });
	}
	operator auto() {
		return OutputMap;
	}
};

auto Function::SynchronizeEvaluatedMap(auto OtherEvaluatedMap)->void {
	RefreshEvaluatedMap();
	auto ResultItems = AccessMap<false>(EvaluatedMap, "val");
	auto ReferenceItems = AccessMap(OtherEvaluatedMap, "val");
	for (auto x : ReferenceItems)
		if (x.Type() == ItemTypes::VideoNode)
			ResultItems += static_cast<VideoNode>(x);
		else if (x.Type() == ItemTypes::Float)
			ResultItems += static_cast<double>(x);
		else if (x.Type() == ItemTypes::Int)
			ResultItems += static_cast<std::int64_t>(x);
		else if (x.Type() == ItemTypes::Data)
			ResultItems += static_cast<std::string>(x);
		else if (x.Type() == ItemTypes::VideoFrame)
			ResultItems += static_cast<VideoFrame<char>>(x);
		else if (x.Type() == ItemTypes::Function)
			ResultItems += static_cast<Function>(x);
	if (auto EvaluationState = VaporGlobals::API->getError(OtherEvaluatedMap); EvaluationState != nullptr)
		VaporGlobals::API->setError(EvaluatedMap, EvaluationState);
}

template<auto ContainsMultipleClips, auto NumberOfClips>
auto ExtractEvaluatedClips(auto EvaluatedMap) {
	auto ClipSequence = AccessMap(EvaluatedMap, "clip");
	if constexpr (ContainsMultipleClips)
		if constexpr (NumberOfClips == IndeterminateSize) {
			auto EvaluatedClips = std::vector<VideoNode>{};
			for (auto&& x : ClipSequence)
				EvaluatedClips.push_back(x);
			return EvaluatedClips;
		}
		else {
			auto EvaluatedClips = std::array<VideoNode, NumberOfClips>{};
			for (auto x : Range{ Utility::Min(NumberOfClips, ClipSequence.size()) })
				EvaluatedClips[x] = ClipSequence[x];
			return EvaluatedClips;
		}
	else
		return static_cast<VideoNode>(ClipSequence);
}

auto ForwardArguments(auto ArgumentMap, auto&& Parameter, auto&& Argument, auto&& ...ArgumentQueue) {
	auto MaterializedParameter = AccessMap<false>(ArgumentMap, Forward(Parameter));
	if constexpr (requires { Argument.begin(); } && !isinstance(Argument, std::string) && !isinstance(Argument, std::string_view))
		for (auto&& x : Argument)
			MaterializedParameter += x;
	else
		MaterializedParameter = Argument;
	if constexpr (sizeof...(ArgumentQueue) != 0)
		ForwardArguments(ArgumentMap, Forward(ArgumentQueue)...);
}