#pragma once
#include "Map.vxx"

struct VaporPlugin final {
	self(Plugin, static_cast<VSPlugin*>(nullptr));
	template<auto HasMultipleOutputs = false, auto NumberOfOutputs = IndefiniteSize>
	struct VaporFilter final {
		self(Plugin, static_cast<VSPlugin*>(nullptr));
		self(Name, ""s);
		self(ErrorMessage, ""s);
		self(FailureFlag, false);
		auto CreateOutputPrototype() {
			if constexpr (HasMultipleOutputs)
				if constexpr (NumberOfOutputs == IndefiniteSize)
					return std::vector<Clip>{};
				else
					return std::array<Clip, NumberOfOutputs>{};
			else
				return Clip{};
		}
		auto operator()(auto&& ...Arguments) {
			auto ArgumentMap = VaporGlobals::API->createMap();
			auto EvaluatedClips = CreateOutputPrototype();
			if constexpr (sizeof...(Arguments) != 0)
				ForwardArguments(ArgumentMap, Forward(Arguments)...);
			auto EvaluatedItems = VaporGlobals::API->invoke(Plugin, Name.data(), ArgumentMap);
			if (auto EvaluationState = VaporGlobals::API->getError(EvaluatedItems); EvaluationState != nullptr) {
				ErrorMessage = EvaluationState;
				FailureFlag = true;
			}
			else {
				EvaluatedClips = ExtractEvaluatedClips<HasMultipleOutputs, NumberOfOutputs>(EvaluatedItems);
				FailureFlag = false;
			}
			VaporGlobals::API->freeMap(EvaluatedItems);
			VaporGlobals::API->freeMap(ArgumentMap);
			return EvaluatedClips;
		}
		auto EvaluationFailed() {
			return FailureFlag;
		}
		template<auto NumberOfClips = IndefiniteSize>
		auto ConfigureForMultipleOutputsInternal() & {
			return VaporFilter<true, NumberOfClips>{ .Plugin = Plugin, .Name = Name, .ErrorMessage = ErrorMessage, .FailureFlag = FailureFlag };
		}
		template<auto NumberOfClips = IndefiniteSize>
		auto ConfigureForMultipleOutputsInternal() && {
			return VaporFilter<true, NumberOfClips>{ .Plugin = Plugin, .Name = std::move(Name), .ErrorMessage = std::move(ErrorMessage), .FailureFlag = FailureFlag };
		}
	};
	auto operator[](auto&& FilterName) {
		return VaporFilter{ .Plugin = Plugin, .Name = Forward(FilterName) };
	}
};