#pragma once
#include "Map.vxx"

struct VaporPlugin final {
	self(Plugin, static_cast<VSPlugin*>(nullptr));
	template<auto HasMultipleOutputs = false, auto NumberOfOutputs = IndeterminateSize>
	struct VaporFilter final {
		self(Plugin, static_cast<VSPlugin*>(nullptr));
		self(Name, ""s);
		auto CreateOutputPrototype() {
			if constexpr (HasMultipleOutputs)
				if constexpr (NumberOfOutputs == IndeterminateSize)
					return std::vector<Clip>{};
				else
					return std::array<Clip, NumberOfOutputs>{};
			else
				return Clip{};
		}
		auto operator()(auto&& ...Arguments) {
			auto ArgumentMap = VaporGlobals::API->createMap();
			auto EvaluatedClips = CreateOutputPrototype();
			if constexpr (sizeof...(Arguments) != 0)
				ForwardArguments(ArgumentMap, Forward(Arguments)...);
			auto EvaluatedItems = VaporGlobals::API->invoke(Plugin, Name.data(), ArgumentMap);
			if (auto EvaluationState = VaporGlobals::API->getError(EvaluatedItems); EvaluationState != nullptr) {
				auto Error = RuntimeError{ EvaluationState };
				VaporGlobals::API->freeMap(EvaluatedItems);
				VaporGlobals::API->freeMap(ArgumentMap);
				throw Error;
			}
			EvaluatedClips = ExtractEvaluatedClips<HasMultipleOutputs, NumberOfOutputs>(EvaluatedItems);
			VaporGlobals::API->freeMap(EvaluatedItems);
			VaporGlobals::API->freeMap(ArgumentMap);
			return EvaluatedClips;
		}
		template<auto NumberOfClips = IndeterminateSize>
		auto ConfigureForMultipleOutputsInternal() & {
			return VaporFilter<true, NumberOfClips>{ .Plugin = Plugin, .Name = Name };
		}
		template<auto NumberOfClips = IndeterminateSize>
		auto ConfigureForMultipleOutputsInternal() && {
			return VaporFilter<true, NumberOfClips>{ .Plugin = Plugin, .Name = std::move(Name) };
		}
	};
	auto operator[](auto&& FilterName) {
		return VaporFilter{ .Plugin = Plugin, .Name = Forward(FilterName) };
	}
};