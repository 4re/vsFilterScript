#pragma once
#include "Utilities.vxx"
#include "Globals.vxx"

template<typename ArbitraryType>
concept VaporFunctionCompatible = requires(ArbitraryType x) { VaporGlobals::API->freeFunc(x); };

struct Function final {
	self(FunctionHandle, static_cast<VSFuncRef*>(nullptr));
	self(EvaluatedMap, static_cast<VSMap*>(nullptr));
	Function() = default;
	Function(VaporFunctionCompatible auto&& RawFunction) {
		FunctionHandle = Forward(RawFunction);
	}
	auto RefreshEvaluatedMap() {
		if (EvaluatedMap != nullptr)
			VaporGlobals::API->freeMap(EvaluatedMap);
		EvaluatedMap = VaporGlobals::API->createMap();
	}
	auto SynchronizeEvaluatedMap(auto)->void;
	auto& operator=(const Function& OtherFunction) {
		if (this != &OtherFunction) {
			VaporGlobals::API->freeFunc(FunctionHandle);
			FunctionHandle = VaporGlobals::API->cloneFuncRef(OtherFunction.FunctionHandle);
			SynchronizeEvaluatedMap(OtherFunction.EvaluatedMap);
		}
		return *this;
	}
	auto& operator=(Function&& OtherFunction) {
		if (this != &OtherFunction) {
			std::swap(FunctionHandle, OtherFunction.FunctionHandle);
			std::swap(EvaluatedMap, OtherFunction.EvaluatedMap);
		}
		return *this;
	}
	Function(const Function& OtherFunction) {
		*this = OtherFunction;
	}
	Function(Function&& OtherFunction) {
		*this = std::move(OtherFunction);
	}
	~Function() {
		if (EvaluatedMap != nullptr)
			VaporGlobals::API->freeMap(EvaluatedMap);
		VaporGlobals::API->freeFunc(FunctionHandle);
	}
	auto ExtractEvaluatedResult();
	auto operator()(auto&& ...Arguments) {
		auto ArgumentMap = VaporGlobals::API->createMap();
		RefreshEvaluatedMap();
		if constexpr (sizeof...(Arguments) != 0)
			ForwardArguments(ArgumentMap, Forward(Arguments)...);
		VaporGlobals::API->callFunc(FunctionHandle, ArgumentMap, EvaluatedMap, nullptr, nullptr);
		VaporGlobals::API->freeMap(ArgumentMap);
		if (auto EvaluationState = VaporGlobals::API->getError(EvaluatedMap); EvaluationState != nullptr)
			throw RuntimeError{ EvaluationState };
		return ExtractEvaluatedResult();
	}
};