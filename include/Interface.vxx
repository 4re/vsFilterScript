#pragma once
#include "Core.vxx"

namespace VaporInterface {
	template<typename FilterType>
	auto Initialize(auto, auto, auto InstanceData, auto Node, auto Core, auto...) {
		auto Data = reinterpret_cast<FilterType*>(*InstanceData);
		auto VideoInfo = Data->RegisterVideoInfo(VaporCore{ .Instance = Core });
		if constexpr (requires { VideoInfo.Size(); })
			if constexpr (requires { VideoInfo.data(); })
				VaporGlobals::API->setVideoInfo(VideoInfo.data(), VideoInfo.Size(), Node);
			else {
				auto AggregatedVideoInfo = std::vector<VSVideoInfo>{};
				for (auto&& x : VideoInfo)
					AggregatedVideoInfo.push_back(x);
				VaporGlobals::API->setVideoInfo(AggregatedVideoInfo.data(), VideoInfo.Size(), Node);
			}
		else
			VaporGlobals::API->setVideoInfo(&VideoInfo, 1, Node);
	}

	template<typename FilterType>
	auto Delete(auto InstanceData, auto...) {
		auto Data = reinterpret_cast<FilterType*>(InstanceData);
		delete Data;
	}

	template<typename FilterType>
	auto Evaluate(auto Index, auto ActivationReason, auto InstanceData, auto, auto FrameContext, auto Core, auto...) try {
		auto Data = reinterpret_cast<FilterType*>(*InstanceData);
		auto ContextHandle = FrameContextWrapper<FilterType>{ .Handle = FrameContext };
		if (ActivationReason == VSActivationReason::arInitial)
			if constexpr (requires { Data->RequestReferenceFrames(0, FrameContext); })
				Data->RequestReferenceFrames(Index, ContextHandle);
			else
				return Data->DrawFrame(Index, VaporCore{ .Instance = Core }, ContextHandle);
		else if (ActivationReason == VSActivationReason::arAllFramesReady)
			return Data->DrawFrame(Index, VaporCore{ .Instance = Core }, ContextHandle);
		return Frame<void>::NullHandle;
	}
	catch (RuntimeError& ErrorMessage) {
		auto ContextHandle = FrameContextWrapper<FilterType>{ .Handle = FrameContext };
		return ContextHandle.RaiseError(ErrorMessage);
	}

	template<typename FilterType>
	auto Create(auto InputMap, auto OutputMap, auto, auto Core, auto...) try {
		auto Data = FilterType{ ArgumentList{ InputMap } };
		auto Console = Controller<FilterType>{ OutputMap };
		auto SelfEvaluator = [&](auto EvaluatedMap, auto InstanceData) {
			auto AuxiliaryMap = VaporGlobals::API->createMap();
			auto AssumedMultithreadingMode = VSFilterMode::fmParallel;
			auto AssumedCacheFlag = 0;
			if constexpr (requires { &FilterType::MultithreadingMode; })
				AssumedMultithreadingMode = FilterType::MultithreadingMode;
			if constexpr (requires { &FilterType::CacheFlag; })
				AssumedCacheFlag = FilterType::CacheFlag;
			if constexpr (requires { Data.DrawFrame(0, VaporCore{}, FrameContextWrapper<FilterType>{}); })
				VaporGlobals::API->createFilter(AuxiliaryMap, EvaluatedMap, FilterType::Name, Initialize<FilterType>, Evaluate<FilterType>, Delete<FilterType>, AssumedMultithreadingMode, AssumedCacheFlag, InstanceData, Core);
			VaporGlobals::API->freeMap(AuxiliaryMap);
		};
		auto SelfInvoker = [&](auto&& ...Arguments) {
			auto InstanceData = static_cast<FilterType*>(nullptr);
			auto ArgumentMap = VaporGlobals::API->createMap();
			auto EvaluatedMap = VaporGlobals::API->createMap();
			auto MaterializeEvaluatedClips = [&]() {
				if constexpr (requires { InstanceData->RegisterVideoInfo(VaporCore{}); }) {
					using VideoInfoType = decltype(InstanceData->RegisterVideoInfo(VaporCore{}));
					auto VideoInfoPrototype = VideoInfoType{};
					if constexpr (WithConstexprSize(VideoInfoPrototype))
						return ExtractEvaluatedClips<true, VideoInfoPrototype.Size()>(EvaluatedMap);
					else
						return ExtractEvaluatedClips<requires { VideoInfoPrototype.Size(); }, IndeterminateSize>(EvaluatedMap);
				}
				else
					return ExtractEvaluatedClips<true, IndeterminateSize>(EvaluatedMap);
			};
			if constexpr (sizeof...(Arguments) != 0)
				ForwardArguments(ArgumentMap, Forward(Arguments)...);
			try {
				InstanceData = new FilterType{ ArgumentList{ ArgumentMap } };
			}
			catch (...) {
				VaporGlobals::API->freeMap(EvaluatedMap);
				VaporGlobals::API->freeMap(ArgumentMap);
				throw;
			}
			SelfEvaluator(EvaluatedMap, InstanceData);
			auto EvaluatedClips = MaterializeEvaluatedClips();
			VaporGlobals::API->freeMap(EvaluatedMap);
			VaporGlobals::API->freeMap(ArgumentMap);
			return EvaluatedClips;
		};
		if constexpr (requires { Data.RegisterInvokingSequence(VaporCore{}, SelfInvoker); })
			Console.Receive(Data.RegisterInvokingSequence(VaporCore{ .Instance = Core }, SelfInvoker));
		else
			SelfEvaluator(OutputMap, new FilterType{ std::move(Data) });
	}
	catch (RuntimeError& ErrorMessage) {
		auto Console = Controller<FilterType>{ OutputMap };
		Console.RaiseError(ErrorMessage);
	}

	template<typename FilterType>
	auto RegisterFilter(auto Broker, auto Plugin) {
		Broker(FilterType::Name, FilterType::Parameters, Create<FilterType>, nullptr, Plugin);
	}

	auto RegisterPlugin(auto Broker, auto Plugin) {
		VaporGlobals::API = getVapourSynthAPI(VAPOURSYNTH_API_VERSION);
		Broker(VaporGlobals::Identifier, VaporGlobals::Namespace, VaporGlobals::Description, VAPOURSYNTH_API_VERSION, 1, Plugin);
	}
}